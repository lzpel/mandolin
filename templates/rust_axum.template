#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
{% include "RUST_SCHEMA" %}
{% include "RUST_OPERATION" %}
// This is generated by mandolin https://github.com/lzpel/mandolin from OpenApi specification

/* Cargo.toml for build this server

[dependencies]
serde= "*"
serde_json= "*"
axum="*"
tokio = { version = "*", features = ["rt", "rt-multi-thread", "macros", "signal"] }
# optional
uuid = { version = "*", features = ["serde"] }
chrono = { version = "*", features = ["serde"] }
*/

use std::collections::HashMap;
use serde;
use std::future::Future;
pub trait ApiInterface{
{%- for pointer, operation in ls_operation() %}
	// {{(pointer|split)[-1]}} {{(pointer|split)[-2]}}
	fn {{OPERATION_NAME(pointer,operation)}}(&self, _req: {{OPERATION_REQUEST_NAME(pointer,operation)}}) -> impl Future<Output = {{OPERATION_RESPONSE_NAME(pointer,operation)}}> + Send{async{Default::default()}}
{%- endfor %}
}
/*
pub struct TestServer{}
impl server::ApiInterface for TestServer{
{%- for pointer, operation in ls_operation() %}
	// {{(pointer|split)[-1]}} {{(pointer|split)[-2]}}
	async fn {{OPERATION_NAME(pointer,operation)}}(&self, _req: {{OPERATION_REQUEST_NAME(pointer,operation)}}) -> {{OPERATION_RESPONSE_NAME(pointer,operation)}}{Default::default()}
{%- endfor %}
}
*/
{%- for pointer, operation in ls_operation() %}
{{OPERATION_REQUEST(pointer, operation, "axum::http::Request<axum::body::Body>")}}
{{OPERATION_RESPONSE(pointer, operation, "axum::response::Response")}}
{%- endfor %}
{{ IDENTIFIED_SCHEMA_DRAIN() }}

use axum;
#[allow(dead_code)]
fn text_response(code: axum::http::StatusCode, body: String)->axum::response::Response{
	axum::response::Response::builder().header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(body)).unwrap()
}
pub fn axum_router_operations<S: ApiInterface + Sync + Send + 'static>(instance :std::sync::Arc<S>)->axum::Router{
	let router = axum::Router::new();
{%- for pointer, operation in ls_operation() %}
	let i = instance.clone();
	let router = router.route("{{(pointer|split)[-2]|re_replace('(\\{\\s*)path', '$1*path')}}", axum::routing::{{(pointer|split)[-1]}}(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::{{OPERATION_NAME(pointer,operation)}}(i.as_ref(), {{OPERATION_REQUEST_NAME(pointer,operation)}}{
{%- for parameter in operation.parameters|include_ref %}
{%- with parameter=parameter|include_ref %}
				r#{{parameter.name}}:{let v={{parameter.in}}.get("{{parameter.name}}")
{%- if parameter.in == "header" %}.map(|v| v.to_str().unwrap_or_default())
{%- endif %}.and_then(|v| v.parse().ok());
{%- if parameter.required -%}match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: {{parameter.name}} in {{parameter.in}}={:?}", {{parameter.in}}))}
{%- else %}v
{%- endif %}},
{%- endwith %}
{%- endfor %}
{%- if operation.requestBody %}
{%- for content_key, content in operation.requestBody.content|items %}
				body:
{%- if "json" in content_key %}match axum::body::to_bytes(body,  usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)}
{%- else %}body.into()
{%- endif %}
{%- break %}
{%- endfor %},
{%- endif %}
				request: axum::http::Request::from_parts(parts, Default::default()),{#- reconstruct here without body which droped #}
			}).await;
			match ret{
{%- for response_key, response in operation.responses|items %}
				{{OPERATION_RESPONSE_NAME(pointer,operation)}}::{{("status_"+response_key)|to_pascal_case}}{%- if response.content -%}(v){%- endif -%} => axum::response::Response::builder().status(axum::http::StatusCode::from_u16({{response_key|replace("default","500")}}).unwrap())
{%- if response.content %}
{%- for contentType, media in response.content|items %}.header(axum::http::header::CONTENT_TYPE, "{{contentType}}")
{%- if "json" in contentType %}.body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json")))
{%- elif media.schema.format and media.schema.format == "binary" %}.body(axum::body::Body::from(v))
{%- else %}.body(axum::body::Body::from(v))
{%- endif %}
{%- break %}
{%- endfor %}
{%- else -%}
.header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("{{response.description}}"))
{%- endif -%}
.unwrap(),
{%- endfor %}
				{{OPERATION_RESPONSE_NAME(pointer,operation)}}::Raw(v)=>v,
			}
		}));
{%- endfor %}
	let router = router.route("/openapi.json", axum::routing::get(|| async move{
			r###"{{"#"|include_pointer|tojson}}"###
		}))
		.route("/ui", axum::routing::get(|| async move{
			axum::response::Html(r###"
			<html lang="en">
			<head>
			  <meta charset="utf-8" />
			  <meta name="viewport" content="width=device-width, initial-scale=1" />
			  <meta name="description" content="SwaggerUI" />
			  <title>SwaggerUI</title>
			  <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />
			</head>
			<body>
			<div id="swagger-ui"></div>
			<script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>
			<script>
			  window.onload = () => {
				window.ui = SwaggerUIBundle({
				  url: location.href.replace("/ui","/openapi.json"),
				  dom_id: '#swagger-ui',
				});
			  };
			</script>
			</body>
			</html>
			"###)
		}));
	return router;
}
{% with servers = ls("#/servers/") %}
pub fn axum_router<S: ApiInterface + Sync + Send + 'static>(instance: S)->axum::Router{
	let instance_arc=std::sync::Arc::new(instance);
{%- if ls("#/servers/")|length > 0 %}
	axum::Router::new()
{%- for pointer, server in ls("#/servers/") %}
		.nest_service("{{server.url}}", axum_router_operations(instance_arc.clone()))
{%- endfor %}
{%- else %}
	panic!("At least, one server define is required for mandolin. but no servers are define in openapi.");
{%- endif %}
}

pub fn print_axum_router(port:u16){
{%- if servers|length > 0%}
{%- for pointer, server in servers %}
	println!("http://localhost:{}{{server.url}}/ui", port);
{%- endfor %}
{%- else%}
	todo!("Add at least one server endpoint to the OpenAPI `servers` section.")
{%- endif%}
}
{% endwith %}
pub struct TestServer{}
impl ApiInterface for TestServer{}
#[allow(dead_code)]
#[tokio::main]
async fn main() {
	let port:u16 = std::env::var("PORT").unwrap_or("8080".to_string()).parse().expect("PORT should be integer");
	print_axum_router(port);
	let api = TestServer{};
	let app = axum_router(api).layer(axum::extract::DefaultBodyLimit::disable());
	let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{port}")).await.unwrap();
	axum::serve(listener, app)
		.with_graceful_shutdown(async { tokio::signal::ctrl_c().await.unwrap() })
		.await
		.unwrap();
}