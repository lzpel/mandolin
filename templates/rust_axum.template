
{% include "RUST_SCHEMA" %}
{% include "RUST_OPERATION" %}
{% include "RUST_AXUM_EXTENSION" %}
// This is generated by mandolin https://github.com/lzpel/mandolin from OpenApi specification

/* Cargo.toml for build this server

[dependencies]
serde= { version="*", features = ["derive"] }
serde_json= "*"
axum = { version = "*", features = ["multipart"] }
tokio = { version = "*", features = ["rt", "rt-multi-thread", "macros", "signal"] }
# optional
uuid = { version = "*", features = ["serde"] }
chrono = { version = "*", features = ["serde"] }
*/

use std::collections::HashMap;
use serde;
use std::future::Future;
pub trait ApiInterface{
	fn authorize(&self, _req: axum::http::Request<axum::body::Body>) -> impl Future<Output = Result<AuthContext, String>> + Send{async { Ok(Default::default()) } }
{%- for pointer, operation in ls_operation() %}
	// {{(pointer|split)[-1]}} {{(pointer|split)[-2]}}
	fn {{OPERATION_NAME(pointer,operation)}}(&self, _req: {{OPERATION_REQUEST_NAME(pointer,operation)}}) -> impl Future<Output = {{OPERATION_RESPONSE_NAME(pointer,operation)}}> + Send{async{Default::default()}}
{%- endfor %}
}


#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct AuthContext{
    pub subject: String,   // user identifier (e.g. "auth0|123", "google-oauth2|456")
    pub subject_id: u128,  // UUID-compatible numeric ID
    pub scopes: Vec<String>, // e.g. "read:foo", "write:bar"
}

{%- for pointer, operation in ls_operation() %}
{{OPERATION_REQUEST(pointer, operation, "axum::http::Request<axum::body::Body>", "AuthContext")}}
{{OPERATION_RESPONSE(pointer, operation, "axum::response::Response")}}
{%- endfor %}
{{ IDENTIFIED_SCHEMA_DRAIN() }}

use axum;
use axum::extract::FromRequest;
fn text_response(code: axum::http::StatusCode, body: String)->axum::response::Response{
	axum::response::Response::builder()
		.status(code)
		.header(axum::http::header::CONTENT_TYPE, "text/plain")
		.body(axum::body::Body::from(body))
		.unwrap()
}
pub fn axum_router_operations<S: ApiInterface + Sync + Send + 'static>(instance :std::sync::Arc<S>)->axum::Router{
	let router = axum::Router::new();
{%- for pointer, operation in ls_operation() %}
	let i = instance.clone();
	let router = router.route("{{(pointer|split)[-2]|re_replace('(\\{\\s*)path', '$1*path')}}", axum::routing::{{(pointer|split)[-1]}}(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::{{OPERATION_NAME(pointer,operation)}}(i.as_ref(), {{OPERATION_REQUEST_NAME(pointer,operation)}}{
{%- for parameter in operation.parameters|include_ref %}
{%- with parameter=parameter|include_ref %}
				r#{{parameter.name}}:{let v={{parameter.in}}.get("{{parameter.name}}")
{%- if parameter.in == "header" %}.map(|v| v.to_str().unwrap_or_default())
{%- endif %}.and_then(|v| v.parse().ok());
{%- if parameter.required -%}match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: {{parameter.name}} in {{parameter.in}}={:?}", {{parameter.in}}))}
{%- else %}v
{%- endif %}},
{%- endwith %}
{%- endfor %}
{%- if operation.requestBody %}
{%- for content_key, content in operation.requestBody.content|items %}
				body:
{%- if "json" in content_key %}match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)}
{%- elif "multipart" in content_key %}{
	let r=axum::http::Request::from_parts(parts.clone(), body);
	let v=match axum::extract::Multipart::from_request(r, &()).await{Ok(v)=>v,Err(e)=>return text_response(axum::http::StatusCode::BAD_REQUEST, e.body_text())};
	{{EXPRESSION_MULTIPART(pointer+"/requestBody/content/"+content_key|encode+"/schema",content.schema,"v","return text_response(axum::http::StatusCode::BAD_REQUEST,e)")}}
}
{%- else %}match axum::body::to_bytes(body, usize::MAX).await{Ok(v)=>v.into(),Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST,format!("{v:?}"))}
{%- endif %}
{%- break %}
{%- endfor %},
{%- endif %}
				request: axum::http::Request::from_parts(parts.clone(), Default::default()),
{%- if operation.security %}
				security: match i.as_ref().authorize(axum::http::Request::from_parts(parts.clone(), Default::default())).await {
					Ok(v)=>v,
					Err(e)=>return text_response(axum::http::StatusCode::UNAUTHORIZED, e)
				},
{%- endif %}
			}).await;
			match ret{
{%- for response_key, response in operation.responses|items %}
{%- with response_type = OPERATION_RESPONSE_TYPE(pointer+"/responses/"+response_key, response) %}
				{{OPERATION_RESPONSE_NAME(pointer,operation)}}::{{("status_"+response_key)|to_pascal_case}}{%- if response_type -%}(v){%- endif -%} => axum::response::Response::builder().status(axum::http::StatusCode::from_u16({{response_key|replace("default","500")}}).unwrap())
{%- if response_type %}.header(axum::http::header::CONTENT_TYPE, "{{response_type|lines|first}}")
{%- if "application/json" in response_type %}.body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json")))
{%- else %}.body(axum::body::Body::from(v))
{%- endif %}
{%- else -%}
.body(axum::body::Body::empty())
{%- endif -%}
.unwrap(),
{%- endwith %}
{%- endfor %}
				{{OPERATION_RESPONSE_NAME(pointer,operation)}}::Raw(v)=>v,
			}
		}));
{%- endfor %}
	let router = router.route("/openapi.json", axum::routing::get(|| async move{
			r###"{{"#"|include_pointer|tojson}}"###
		}))
		.route("/ui", axum::routing::get(|| async move{
			axum::response::Html(r###"
			<html lang="en">
			<head>
			  <meta charset="utf-8" />
			  <meta name="viewport" content="width=device-width, initial-scale=1" />
			  <meta name="description" content="SwaggerUI" />
			  <title>SwaggerUI</title>
			  <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />
			</head>
			<body>
			<div id="swagger-ui"></div>
			<script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>
			<script>
			  window.onload = () => {
				window.ui = SwaggerUIBundle({
				  url: location.href.replace("/ui","/openapi.json"),
				  dom_id: '#swagger-ui',
				});
			  };
			</script>
			</body>
			</html>
			"###)
		}));
	return router;
}
{% with servers = ls("#/servers/") %}
pub fn axum_router<S: ApiInterface + Sync + Send + 'static>(instance: S)->axum::Router{
	let instance_arc=std::sync::Arc::new(instance);
{%- if ls("#/servers/")|length > 0 %}
	axum::Router::new()
{%- for pointer, server in ls("#/servers/") %}
		.nest_service("{{server.url}}", axum_router_operations(instance_arc.clone()))
{%- endfor %}
{%- else %}
	panic!("At least, one server define is required for mandolin. but no servers are define in openapi.");
{%- endif %}
}

pub fn print_axum_router(port:u16){
{%- if servers|length > 0%}
{%- for pointer, server in servers %}
	println!("http://localhost:{}{{server.url}}/ui", port);
{%- endfor %}
{%- else%}
	todo!("Add at least one server endpoint to the OpenAPI `servers` section.")
{%- endif%}
}
{% endwith %}
pub struct TestServer{}
impl ApiInterface for TestServer{
	// implement necessary method
{%- for pointer, operation in ls_operation() %}
	// {{(pointer|split)[-1]}} {{(pointer|split)[-2]}}
	// async fn {{OPERATION_NAME(pointer,operation)}}(&self, _req: {{OPERATION_REQUEST_NAME(pointer,operation)}}) -> {{OPERATION_RESPONSE_NAME(pointer,operation)}}{Default::default()}
{%- endfor %}
}

{{ UTILITY() }}

#[tokio::main]
async fn main() {
	let port:u16 = std::env::var("PORT").unwrap_or("8080".to_string()).parse().expect("PORT should be integer");
	print_axum_router(port);
	let api = TestServer{};
	let app = axum_router(api).layer(axum::extract::DefaultBodyLimit::disable());
	let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{port}")).await.unwrap();
	axum::serve(listener, app)
		.with_graceful_shutdown(async { tokio::signal::ctrl_c().await.unwrap() })
		.await
		.unwrap();
}