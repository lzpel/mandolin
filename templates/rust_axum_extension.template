{# axumのmultipartを受け取りschema型を返すexpressionです #}
{%- macro EXPRESSION_MULTIPART(pointer,schema,multipart,expression_with_string_e) -%}
match async |mut x: axum::extract::Multipart| -> std::result::Result<{{SCHEMA_NAME(pointer)}},String>{
	let mut o:{{SCHEMA_NAME(pointer)}}=Default::default();
	while let Some(field) = x.next_field().await.map_err(|e| e.body_text())? {
		match field.name().unwrap_or_default() {
{%- if schema.type == "object" %}
{%- for property_key, property in schema.properties|items %}
			"{{property_key}}" => 
{%- with required=schema.required and property_key in schema.required -%}
				{{EXPRESSION_MULTIPART_ITEM(pointer+"/properties/"+property_key, property, "o."+property_key, required)}}
{%- endwith %},
{%- endfor %}
{%- endif %}
			other => return Err(format!("unknown field {other} in multipart-formdata"))
		}
	}
	Ok(o)
}({{multipart}}).await {
	Ok(v)=>v,
	Err(e)=>{{expression_with_string_e}}
}
{%- endmacro %}

{%- macro EXPRESSION_MULTIPART_ITEM(pointer,schema,value,value_is_required) %}
{%- if schema.type == "array" -%}
{{value}}.push({{EXPRESSION_MULTIPART_ITEM(pointer+"/items",schema.items)}})
{%- elif schema.type == "string" %}
{%- if value is defined %}{{value}}={%- if not value_is_required %}Some({%- endif %}{%- endif %}{#- ここから #}
{%- if schema.format == "binary" %}field.bytes().await.map(|v| v.to_vec()).map_err(|e| e.body_text())?
{%- else %}field.text().await.map_err(|e| e.body_text())?
{%- endif %}
{%- if value is defined %}{%- if not value_is_required %}){%- endif %}{%- endif %}{#- ここまで #}
{%- endif %}
{%- endmacro %}

{# ユーティリティ 便利な関数など#}
{%- macro UTILITY() -%}
pub fn origin_from_request<B>(req: &axum::http::Request<B>) -> Option<String> {
	fn first_csv(s: &str) -> &str {
		s.split(',').next().unwrap_or(s).trim()
	}
	fn unquote(s: &str) -> &str {
		let s = s.trim();
		if s.starts_with('"') && s.ends_with('"') && s.len() >= 2 {
			&s[1..s.len() - 1]
		} else {
			s
		}
	}
	fn guess_scheme(host: &str) -> &'static str {
		let hostname = host
			.trim_start_matches('[')
			.split(']')
			.next()
			.unwrap_or(host)
			.split(':')
			.next()
			.unwrap_or(host);
		match hostname {
			"localhost" | "127.0.0.1" | "::1" => "http",
			_ => "https",
		}
	}
	fn mk_origin(proto: Option<String>, host: String) -> String {
		let proto = proto.unwrap_or_else(|| guess_scheme(&host).to_string());
		format!("{proto}://{host}")
	}

	let headers = req.headers();

	// 0) First, check the URI authority (the case where an absolute URI is received).
	//    If we can obtain host:port here, the host is considered determined.
	if let Some(auth) = req.uri().authority() {
		let host = auth.as_str().to_string();
		// The scheme cannot be determined from the Request alone, so it would also be reasonable to design this to inspect Forwarded / X-Forwarded-Proto later.
		// Here, however, we return a value by "guessing" the scheme if no proto is provided.
		return Some(mk_origin(None, host));
	}

	// 1) Forwarded (RFC 7239)
	if let Some(raw) = headers
		.get(axum::http::header::FORWARDED)
		.and_then(|v| v.to_str().ok())
	{
		let first = first_csv(raw);
		let mut proto: Option<String> = None;
		let mut host: Option<String> = None;

		for part in first.split(';') {
			let mut it = part.trim().splitn(2, '=');
			let k = it.next().unwrap_or("").trim().to_ascii_lowercase();
			let v = unquote(it.next().unwrap_or(""));

			match k.as_str() {
				"proto" if !v.is_empty() => proto = Some(v.to_ascii_lowercase()),
				"host" if !v.is_empty() => host = Some(v.to_string()),
				_ => {}
			}
		}

		if let Some(host) = host {
			return Some(mk_origin(proto, host));
		}
	}

	// 2) X-Forwarded-*
	if let Some(mut host) = headers
		.get("x-forwarded-host")
		.and_then(|v| v.to_str().ok())
		.map(first_csv)
		.filter(|s| !s.is_empty())
		.map(str::to_string)
	{
		// If x-forwarded-host does not include a port, supplement it with x-forwarded-port (simplified).
		if !host.contains(':') {
			if let Some(port) = headers
				.get("x-forwarded-port")
				.and_then(|v| v.to_str().ok())
				.map(str::trim)
				.filter(|s| !s.is_empty())
			{
				host = format!("{host}:{port}");
			}
		}

		let proto = headers
			.get("x-forwarded-proto")
			.and_then(|v| v.to_str().ok())
			.map(first_csv)
			.map(|s| s.to_ascii_lowercase())
			.filter(|s| !s.is_empty());

		return Some(mk_origin(proto, host));
	}

	// 3) Host fallback
	let host = headers
		.get(axum::http::header::HOST)
		.and_then(|h| h.to_str().ok())
		.map(str::trim)
		.filter(|s| !s.is_empty())?
		.to_string();

	Some(format!("{}://{}", guess_scheme(&host), host))
}
{%- endmacro -%}