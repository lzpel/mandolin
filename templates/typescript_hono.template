import { Hono } from 'hono'
import { serve } from '@hono/node-server'
{% include "TYPESCRIPT_SCHEMA" %}
{% include "TYPESCRIPT_OPERATION" %}
{% set INTERFACE_NAME="#/info/title"|include_pointer|to_pascal_case%}
// This is generated by mandolin https://github.com/lzpel/mandolin from OpenApi specification

{%- for pointer, operation in ls_operation() %}
{{OPERATION_REQUEST(pointer, operation)}}
{{OPERATION_RESPONSE(pointer, operation)}}
{%- endfor %}
{{ IDENTIFIED_SCHEMA_DRAIN() }}

interface {{INTERFACE_NAME}}{
{%- for pointer, operation in ls_operation() %}
	// {{(pointer|split)[-1]}} {{(pointer|split)[-2]}}
	{{OPERATION_NAME(pointer,operation)}}?(request: {{OPERATION_REQUEST_NAME(pointer,operation)}}): Promise<{{OPERATION_RESPONSE_NAME(pointer,operation)}}>
{%- endfor %}
}

export function addHonoOperations(app: Hono, implement: {{INTERFACE_NAME}}){
{%- for pointer, operation in ls_operation() %}
	app.{{(pointer|split)[-1]}}('{{(pointer|split)[-2]}}', (c) => {
		if (implement.{{OPERATION_NAME(pointer,operation)}}===undefined)return;
		const ret=implement.{{OPERATION_NAME(pointer,operation)}}({{OPERATION_REQUEST_NAME(pointer,operation)}}{
{%- for parameter in operation.parameters|include_ref %}
{%- with parameter=parameter|include_ref %}
				r#{{parameter.name}}:match {{parameter.in}}.get("{{parameter.name}}").and_then(|v| v.parse().ok())
{%- if parameter.required -%}
{Some(v)=>v, None=>return (axum::http::StatusCode::from_u16(400).unwrap(),[(axum::http::header::CONTENT_TYPE, "text/plain")], format!("parse error: {{parameter.name}} in {{parameter.in}}={:?}", {{parameter.in}}).as_bytes().to_vec())}
{%- else -%}
{Some(v)=>Some(v), None=>None}
{%- endif -%},
{%- endwith %}
{%- endfor %}
{%- if operation.requestBody %}
{%- for content_key, content in operation.requestBody.content|items %}
				body:
{%- if "json" in content_key -%}
match serde_json::from_slice(body.to_vec().as_slice()){Ok(v)=>v,Err(v) => { return (axum::http::StatusCode::INTERNAL_SERVER_ERROR,[(axum::http::header::CONTENT_TYPE, "text/plain")], format!("{:?}", v).as_bytes().to_vec())}}
{%- else %}
body.into()
{%- endif %}
{%- break %}
{%- endfor %},
{%- endif %}
			}).await;
			match ret{
{%- for response_key, response in operation.responses|items %}
				{{OPERATION_RESPONSE_NAME(pointer,operation)}}::{{("status_"+response_key)|to_pascal_case}}{%- if response.content -%}(v){%- endif -%} => (axum::http::StatusCode::from_u16({{response_key|replace("default","500")}}).unwrap(),
{%- if response.content %}
{%- for contentType, media in response.content|items %}[(axum::http::header::CONTENT_TYPE, "{{contentType}}")],
{%- if "json" in contentType %}serde_json::to_vec_pretty(&v).expect("error serialize response json")
{%- elif media.schema.format and media.schema.format == "binary" %}v
{%- else %}v.as_bytes().to_vec()
{%- endif %}
{%- break %}
{%- endfor %}
{%- else -%}
[(axum::http::header::CONTENT_TYPE, "text/plain")], "{{response.description}}".as_bytes().to_vec()
{%- endif -%}
),
{%- endfor %}
	})
{%- endfor %}
class TestServer implements SimpleAPI{}
export function main(){
	const app = new Hono()
	addHonoOperations(app,new TestServer());
	serve({
		fetch: app.fetch,
		port: 3000
	}, (info) => {
		console.log(`Server is running on http://localhost:${info.port}`)
	})
}