#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(dead_code)]



// This is generated by mandolin https://github.com/lzpel/mandolin from OpenApi specification

/* Cargo.toml for build this server

[dependencies]
serde= "*"
serde_json= "*"
axum = { version = "*", features = ["multipart"]}
tokio = { version = "*", features = ["rt", "rt-multi-thread", "macros", "signal"] }
# optional
uuid = { version = "*", features = ["serde"] }
chrono = { version = "*", features = ["serde"] }
*/

use std::collections::HashMap;
use serde;
use std::future::Future;
pub trait ApiInterface{
	// get /auth/github/login
	fn paths_auth_github_login_get(&self, _req: PathsAuthGithubLoginGetRequest) -> impl Future<Output = PathsAuthGithubLoginGetResponse> + Send{async{Default::default()}}
	// get /auth/google/login
	fn paths_auth_google_login_get(&self, _req: PathsAuthGoogleLoginGetRequest) -> impl Future<Output = PathsAuthGoogleLoginGetResponse> + Send{async{Default::default()}}
	// get /auth/callback
	fn paths_auth_callback_get(&self, _req: PathsAuthCallbackGetRequest) -> impl Future<Output = PathsAuthCallbackGetResponse> + Send{async{Default::default()}}
	// get /users/me
	fn paths_users_me_get(&self, _req: PathsUsersMeGetRequest) -> impl Future<Output = PathsUsersMeGetResponse> + Send{async{Default::default()}}
}
/*
pub struct TestServer{}
impl server::ApiInterface for TestServer{
	// get /auth/github/login
	async fn paths_auth_github_login_get(&self, _req: PathsAuthGithubLoginGetRequest) -> PathsAuthGithubLoginGetResponse{Default::default()}
	// get /auth/google/login
	async fn paths_auth_google_login_get(&self, _req: PathsAuthGoogleLoginGetRequest) -> PathsAuthGoogleLoginGetResponse{Default::default()}
	// get /auth/callback
	async fn paths_auth_callback_get(&self, _req: PathsAuthCallbackGetRequest) -> PathsAuthCallbackGetResponse{Default::default()}
	// get /users/me
	async fn paths_users_me_get(&self, _req: PathsUsersMeGetRequest) -> PathsUsersMeGetResponse{Default::default()}
}
*/
// Request of paths_auth_github_login_get
#[derive(Debug)]
pub struct PathsAuthGithubLoginGetRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of paths_auth_github_login_get
#[derive(Debug)]
pub enum PathsAuthGithubLoginGetResponse{
	Status302,
	Raw(axum::response::Response),
}
impl Default for PathsAuthGithubLoginGetResponse{
	fn default() -> Self{
		Self::Status302
	}
}
// Request of paths_auth_google_login_get
#[derive(Debug)]
pub struct PathsAuthGoogleLoginGetRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of paths_auth_google_login_get
#[derive(Debug)]
pub enum PathsAuthGoogleLoginGetResponse{
	Status302,
	Raw(axum::response::Response),
}
impl Default for PathsAuthGoogleLoginGetResponse{
	fn default() -> Self{
		Self::Status302
	}
}
// Request of paths_auth_callback_get
#[derive(Debug)]
pub struct PathsAuthCallbackGetRequest{
	pub code:String,
	pub state:Option<String>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of paths_auth_callback_get
#[derive(Debug)]
pub enum PathsAuthCallbackGetResponse{
	Status200(PathsAuthCallbackGetResponses200ContentApplicationJsonSchema),
	Raw(axum::response::Response),
}
impl Default for PathsAuthCallbackGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of paths_users_me_get
#[derive(Debug)]
pub struct PathsUsersMeGetRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of paths_users_me_get
#[derive(Debug)]
pub enum PathsUsersMeGetResponse{
	Status200(PathsUsersMeGetResponses200ContentApplicationJsonSchema),
	Status401,
	Raw(axum::response::Response),
}
impl Default for PathsUsersMeGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}

#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct PathsAuthCallbackGetResponses200ContentApplicationJsonSchema{
	pub r#access_token:Option<String>,
	pub r#token_type:Option<String>,
	pub r#expires_in:Option<i8>,
	pub r#user:Option<PathsAuthCallbackGetResponses200ContentApplicationJsonSchemaPropertiesUser>,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct PathsUsersMeGetResponses200ContentApplicationJsonSchema{
	pub r#id:Option<String>,
	pub r#email:Option<String>,
	pub r#name:Option<String>,
	pub r#provider:Option<String>,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct PathsAuthCallbackGetResponses200ContentApplicationJsonSchemaPropertiesUser{
	pub r#id:Option<String>,
	pub r#provider:Option<String>,
	pub r#email:Option<String>,
	pub r#name:Option<String>,
}

use axum;
#[allow(unused_imports)]
use axum::extract::FromRequest;
fn text_response(code: axum::http::StatusCode, body: String)->axum::response::Response{
	axum::response::Response::builder().header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(body)).unwrap()
}
pub fn axum_router_operations<S: ApiInterface + Sync + Send + 'static>(instance :std::sync::Arc<S>)->axum::Router{
	let router = axum::Router::new();
	let i = instance.clone();
	let router = router.route("/auth/github/login", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::paths_auth_github_login_get(i.as_ref(), PathsAuthGithubLoginGetRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				PathsAuthGithubLoginGetResponse::Status302=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(302).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("Redirect to GitHub authorization URL")).unwrap(),
				PathsAuthGithubLoginGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/auth/google/login", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::paths_auth_google_login_get(i.as_ref(), PathsAuthGoogleLoginGetRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				PathsAuthGoogleLoginGetResponse::Status302=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(302).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("Redirect to Google authorization URL")).unwrap(),
				PathsAuthGoogleLoginGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/auth/callback", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::paths_auth_callback_get(i.as_ref(), PathsAuthCallbackGetRequest{
				r#code:{let v=query.get("code").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: code in query={:?}", query))}},
				r#state:{let v=query.get("state").and_then(|v| v.parse().ok());v},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				PathsAuthCallbackGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				PathsAuthCallbackGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/users/me", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::paths_users_me_get(i.as_ref(), PathsUsersMeGetRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				PathsUsersMeGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				PathsUsersMeGetResponse::Status401=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(401).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("Unauthorized or invalid token")).unwrap(),
				PathsUsersMeGetResponse::Raw(v)=>v,
			}
		}));
	let router = router.route("/openapi.json", axum::routing::get(|| async move{
			r###"{"openapi":"3.1.0","info":{"title":"Multi-OAuth Login API","description":"A service where users can log in via **GitHub** or **Google**, then receive a self-issued JWT\nused for subsequent API calls (such as `/users/me`).\n","version":"1.0.0"},"servers":[{"url":"https://api.example.com","description":"Production server"}],"paths":{"/auth/github/login":{"get":{"summary":"Redirect user to GitHub OAuth2","description":"Redirects the client to GitHub\u0027s OAuth2 authorization URL.\nThe user authorizes and is redirected back to `/auth/callback`.\n","responses":{"302":{"description":"Redirect to GitHub authorization URL"}}}},"/auth/google/login":{"get":{"summary":"Redirect user to Google OAuth2","description":"Redirects the client to Google\u0027s OAuth2 authorization URL.\nThe user authorizes and is redirected back to `/auth/callback`.\n","responses":{"302":{"description":"Redirect to Google authorization URL"}}}},"/auth/callback":{"get":{"summary":"OAuth2 callback endpoint","description":"Handles the OAuth2 callback from either GitHub or Google.\nExchanges the authorization code for tokens, verifies the user,\ncreates or retrieves the user record, and issues an internal JWT.\n","parameters":[{"in":"query","name":"code","description":"Authorization code returned by the OAuth2 provider.","required":true,"schema":{"type":"string"},"style":"form"},{"in":"query","name":"state","description":"Opaque value used to maintain state between request and callback.","schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"Successfully issued internal JWT.","content":{"application/json":{"schema":{"type":"object","properties":{"access_token":{"description":"Self-issued JWT for authenticated requests.","type":"string"},"token_type":{"example":"Bearer","type":"string"},"expires_in":{"example":3600,"type":"integer"},"user":{"type":"object","properties":{"id":{"type":"string"},"provider":{"type":"string","enum":["google","github"]},"email":{"type":"string"},"name":{"type":"string"}}}}}}}}}}},"/users/me":{"get":{"summary":"Get current user info","description":"Returns the authenticated user\u0027s information.\nRequires a valid **self-issued JWT** obtained from `/auth/callback`.\n","responses":{"200":{"description":"Authenticated user info","content":{"application/json":{"schema":{"type":"object","properties":{"id":{"type":"string"},"email":{"type":"string"},"name":{"type":"string"},"provider":{"type":"string","enum":["google","github"]}}}}}},"401":{"description":"Unauthorized or invalid token"}},"security":[{"ServiceJWT":[]}]}}},"components":{"securitySchemes":{"OAuth2_Google":{"type":"oauth2","flows":{"authorizationCode":{"authorizationUrl":"https://accounts.google.com/o/oauth2/v2/auth","tokenUrl":"https://oauth2.googleapis.com/token","scopes":{"openid":"Access user\u0027s basic profile","email":"Access user\u0027s email address","profile":"Access user\u0027s name and picture"}}},"description":"Google OAuth2 Authorization Code Flow"},"OAuth2_GitHub":{"type":"oauth2","flows":{"authorizationCode":{"authorizationUrl":"https://github.com/login/oauth/authorize","tokenUrl":"https://github.com/login/oauth/access_token","scopes":{"read:user":"Read the authenticated user\u0027s profile data","user:email":"Access user\u0027s email addresses"}}},"description":"GitHub OAuth2 Authorization Code Flow"},"ServiceJWT":{"type":"http","scheme":"bearer","bearerFormat":"JWT","description":"Self-issued JWT generated by this API after successful OAuth2 login.\nUsed for all authenticated endpoints such as `/users/me`.\n"}}},"security":[{"ServiceJWT":[]}]}"###
		}))
		.route("/ui", axum::routing::get(|| async move{
			axum::response::Html(r###"
			<html lang="en">
			<head>
			  <meta charset="utf-8" />
			  <meta name="viewport" content="width=device-width, initial-scale=1" />
			  <meta name="description" content="SwaggerUI" />
			  <title>SwaggerUI</title>
			  <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />
			</head>
			<body>
			<div id="swagger-ui"></div>
			<script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>
			<script>
			  window.onload = () => {
				window.ui = SwaggerUIBundle({
				  url: location.href.replace("/ui","/openapi.json"),
				  dom_id: '#swagger-ui',
				});
			  };
			</script>
			</body>
			</html>
			"###)
		}));
	return router;
}

pub fn axum_router<S: ApiInterface + Sync + Send + 'static>(instance: S)->axum::Router{
	let instance_arc=std::sync::Arc::new(instance);
	axum::Router::new()
		.nest_service("/api", axum_router_operations(instance_arc.clone()))
}

pub fn print_axum_router(port:u16){
	println!("http://localhost:{}/api", port);
}

pub struct TestServer{}
impl ApiInterface for TestServer{}
#[allow(dead_code)]
#[tokio::main]
async fn main() {
	let port:u16 = std::env::var("PORT").unwrap_or("8080".to_string()).parse().expect("PORT should be integer");
	print_axum_router(port);
	let api = TestServer{};
	let app = axum_router(api).layer(axum::extract::DefaultBodyLimit::disable());
	let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{port}")).await.unwrap();
	axum::serve(listener, app)
		.with_graceful_shutdown(async { tokio::signal::ctrl_c().await.unwrap() })
		.await
		.unwrap();
}
