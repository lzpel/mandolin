#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(dead_code)]



// This is generated by mandolin https://github.com/lzpel/mandolin from OpenApi specification

/* Cargo.toml for build this server

[dependencies]
serde= "*"
serde_json= "*"
axum = { version = "*", features = ["multipart"]}
tokio = { version = "*", features = ["rt", "rt-multi-thread", "macros", "signal"] }
# optional
uuid = { version = "*", features = ["serde"] }
chrono = { version = "*", features = ["serde"] }
*/

use std::collections::HashMap;
use serde;
use std::future::Future;
pub trait ApiInterface{
	// delete /clean
	fn operation_clean(&self, _req: OperationCleanRequest) -> impl Future<Output = OperationCleanResponse> + Send{async{Default::default()}}
	// get /credential/iam
	fn credential_get(&self, _req: CredentialGetRequest) -> impl Future<Output = CredentialGetResponse> + Send{async{Default::default()}}
	// post /credential/sign_in
	fn credential_sign_in(&self, _req: CredentialSignInRequest) -> impl Future<Output = CredentialSignInResponse> + Send{async{Default::default()}}
	// post /credential/sign_up
	fn credential_sign_up(&self, _req: CredentialSignUpRequest) -> impl Future<Output = CredentialSignUpResponse> + Send{async{Default::default()}}
	// get /credential/validate
	fn credential_validate(&self, _req: CredentialValidateRequest) -> impl Future<Output = CredentialValidateResponse> + Send{async{Default::default()}}
	// get /device
	fn device_list_get(&self, _req: DeviceListGetRequest) -> impl Future<Output = DeviceListGetResponse> + Send{async{Default::default()}}
	// post /device
	fn device_list_add(&self, _req: DeviceListAddRequest) -> impl Future<Output = DeviceListAddResponse> + Send{async{Default::default()}}
	// get /device/{key}
	fn device_get(&self, _req: DeviceGetRequest) -> impl Future<Output = DeviceGetResponse> + Send{async{Default::default()}}
	// post /device/{key}
	fn device_update(&self, _req: DeviceUpdateRequest) -> impl Future<Output = DeviceUpdateResponse> + Send{async{Default::default()}}
	// delete /device/{key}
	fn device_delete(&self, _req: DeviceDeleteRequest) -> impl Future<Output = DeviceDeleteResponse> + Send{async{Default::default()}}
	// get /key/{key}
	fn operation_key(&self, _req: OperationKeyRequest) -> impl Future<Output = OperationKeyResponse> + Send{async{Default::default()}}
	// post /ml/image
	fn ml_image(&self, _req: MlImageRequest) -> impl Future<Output = MlImageResponse> + Send{async{Default::default()}}
	// post /ml/json
	fn ml_json(&self, _req: MlJsonRequest) -> impl Future<Output = MlJsonResponse> + Send{async{Default::default()}}
	// get /record
	fn record_list_get(&self, _req: RecordListGetRequest) -> impl Future<Output = RecordListGetResponse> + Send{async{Default::default()}}
	// post /record
	fn record_list_add(&self, _req: RecordListAddRequest) -> impl Future<Output = RecordListAddResponse> + Send{async{Default::default()}}
	// get /record/{key}
	fn record_get(&self, _req: RecordGetRequest) -> impl Future<Output = RecordGetResponse> + Send{async{Default::default()}}
	// post /record/{key}
	fn record_update(&self, _req: RecordUpdateRequest) -> impl Future<Output = RecordUpdateResponse> + Send{async{Default::default()}}
	// delete /record/{key}
	fn record_delete(&self, _req: RecordDeleteRequest) -> impl Future<Output = RecordDeleteResponse> + Send{async{Default::default()}}
	// get /test
	fn test_b(&self, _req: TestBRequest) -> impl Future<Output = TestBResponse> + Send{async{Default::default()}}
	// put /test
	fn test_d(&self, _req: TestDRequest) -> impl Future<Output = TestDResponse> + Send{async{Default::default()}}
	// post /test
	fn test_c(&self, _req: TestCRequest) -> impl Future<Output = TestCResponse> + Send{async{Default::default()}}
	// delete /test
	fn test_a(&self, _req: TestARequest) -> impl Future<Output = TestAResponse> + Send{async{Default::default()}}
	// get /user
	fn user_list_get(&self, _req: UserListGetRequest) -> impl Future<Output = UserListGetResponse> + Send{async{Default::default()}}
	// get /user/{key}
	fn user_get(&self, _req: UserGetRequest) -> impl Future<Output = UserGetResponse> + Send{async{Default::default()}}
	// post /user/{key}
	fn user_update(&self, _req: UserUpdateRequest) -> impl Future<Output = UserUpdateResponse> + Send{async{Default::default()}}
	// delete /user/{key}
	fn user_delete(&self, _req: UserDeleteRequest) -> impl Future<Output = UserDeleteResponse> + Send{async{Default::default()}}
}
/*
pub struct TestServer{}
impl server::ApiInterface for TestServer{
	// delete /clean
	async fn operation_clean(&self, _req: OperationCleanRequest) -> OperationCleanResponse{Default::default()}
	// get /credential/iam
	async fn credential_get(&self, _req: CredentialGetRequest) -> CredentialGetResponse{Default::default()}
	// post /credential/sign_in
	async fn credential_sign_in(&self, _req: CredentialSignInRequest) -> CredentialSignInResponse{Default::default()}
	// post /credential/sign_up
	async fn credential_sign_up(&self, _req: CredentialSignUpRequest) -> CredentialSignUpResponse{Default::default()}
	// get /credential/validate
	async fn credential_validate(&self, _req: CredentialValidateRequest) -> CredentialValidateResponse{Default::default()}
	// get /device
	async fn device_list_get(&self, _req: DeviceListGetRequest) -> DeviceListGetResponse{Default::default()}
	// post /device
	async fn device_list_add(&self, _req: DeviceListAddRequest) -> DeviceListAddResponse{Default::default()}
	// get /device/{key}
	async fn device_get(&self, _req: DeviceGetRequest) -> DeviceGetResponse{Default::default()}
	// post /device/{key}
	async fn device_update(&self, _req: DeviceUpdateRequest) -> DeviceUpdateResponse{Default::default()}
	// delete /device/{key}
	async fn device_delete(&self, _req: DeviceDeleteRequest) -> DeviceDeleteResponse{Default::default()}
	// get /key/{key}
	async fn operation_key(&self, _req: OperationKeyRequest) -> OperationKeyResponse{Default::default()}
	// post /ml/image
	async fn ml_image(&self, _req: MlImageRequest) -> MlImageResponse{Default::default()}
	// post /ml/json
	async fn ml_json(&self, _req: MlJsonRequest) -> MlJsonResponse{Default::default()}
	// get /record
	async fn record_list_get(&self, _req: RecordListGetRequest) -> RecordListGetResponse{Default::default()}
	// post /record
	async fn record_list_add(&self, _req: RecordListAddRequest) -> RecordListAddResponse{Default::default()}
	// get /record/{key}
	async fn record_get(&self, _req: RecordGetRequest) -> RecordGetResponse{Default::default()}
	// post /record/{key}
	async fn record_update(&self, _req: RecordUpdateRequest) -> RecordUpdateResponse{Default::default()}
	// delete /record/{key}
	async fn record_delete(&self, _req: RecordDeleteRequest) -> RecordDeleteResponse{Default::default()}
	// get /test
	async fn test_b(&self, _req: TestBRequest) -> TestBResponse{Default::default()}
	// put /test
	async fn test_d(&self, _req: TestDRequest) -> TestDResponse{Default::default()}
	// post /test
	async fn test_c(&self, _req: TestCRequest) -> TestCResponse{Default::default()}
	// delete /test
	async fn test_a(&self, _req: TestARequest) -> TestAResponse{Default::default()}
	// get /user
	async fn user_list_get(&self, _req: UserListGetRequest) -> UserListGetResponse{Default::default()}
	// get /user/{key}
	async fn user_get(&self, _req: UserGetRequest) -> UserGetResponse{Default::default()}
	// post /user/{key}
	async fn user_update(&self, _req: UserUpdateRequest) -> UserUpdateResponse{Default::default()}
	// delete /user/{key}
	async fn user_delete(&self, _req: UserDeleteRequest) -> UserDeleteResponse{Default::default()}
}
*/
// Request of operation_clean
#[derive(Debug)]
pub struct OperationCleanRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of operation_clean
#[derive(Debug)]
pub enum OperationCleanResponse{
	Status200(String),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for OperationCleanResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of credential_get
#[derive(Debug)]
pub struct CredentialGetRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of credential_get
#[derive(Debug)]
pub enum CredentialGetResponse{
	Status200(User),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for CredentialGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of credential_sign_in
#[derive(Debug)]
pub struct CredentialSignInRequest{
	pub body: PathsCredentialSignInPostRequestbodyContentApplicationJsonSchema,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of credential_sign_in
#[derive(Debug)]
pub enum CredentialSignInResponse{
	Status200(String),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for CredentialSignInResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of credential_sign_up
#[derive(Debug)]
pub struct CredentialSignUpRequest{
	pub body: User,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of credential_sign_up
#[derive(Debug)]
pub enum CredentialSignUpResponse{
	Status200(String),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for CredentialSignUpResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of credential_validate
#[derive(Debug)]
pub struct CredentialValidateRequest{
	pub body: String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of credential_validate
#[derive(Debug)]
pub enum CredentialValidateResponse{
	Status200(Apikey),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for CredentialValidateResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of device_list_get
#[derive(Debug)]
pub struct DeviceListGetRequest{
	pub limit:Option<i32>,
	pub order:Option<String>,
	pub max_key:Option<String>,
	pub min_key:Option<String>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of device_list_get
#[derive(Debug)]
pub enum DeviceListGetResponse{
	Status200(Vec<Device>),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for DeviceListGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of device_list_add
#[derive(Debug)]
pub struct DeviceListAddRequest{
	pub body: Device,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of device_list_add
#[derive(Debug)]
pub enum DeviceListAddResponse{
	Status200(Device),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for DeviceListAddResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of device_get
#[derive(Debug)]
pub struct DeviceGetRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of device_get
#[derive(Debug)]
pub enum DeviceGetResponse{
	Status200(Device),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for DeviceGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of device_update
#[derive(Debug)]
pub struct DeviceUpdateRequest{
	pub key:String,
	pub body: Device,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of device_update
#[derive(Debug)]
pub enum DeviceUpdateResponse{
	Status200(Device),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for DeviceUpdateResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of device_delete
#[derive(Debug)]
pub struct DeviceDeleteRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of device_delete
#[derive(Debug)]
pub enum DeviceDeleteResponse{
	Status200,
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for DeviceDeleteResponse{
	fn default() -> Self{
		Self::Status200
	}
}
// Request of operation_key
#[derive(Debug)]
pub struct OperationKeyRequest{
	pub key:String,
	pub seconds:Option<i64>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of operation_key
#[derive(Debug)]
pub enum OperationKeyResponse{
	Status200(String),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for OperationKeyResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of ml_image
#[derive(Debug)]
pub struct MlImageRequest{
	pub body: Vec<u8>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of ml_image
#[derive(Debug)]
pub enum MlImageResponse{
	Status200(Vec<u8>),
	Raw(axum::response::Response),
}
impl Default for MlImageResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of ml_json
#[derive(Debug)]
pub struct MlJsonRequest{
	pub body: Vec<u8>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of ml_json
#[derive(Debug)]
pub enum MlJsonResponse{
	Status200(String),
	Raw(axum::response::Response),
}
impl Default for MlJsonResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of record_list_get
#[derive(Debug)]
pub struct RecordListGetRequest{
	pub limit:Option<i32>,
	pub order:Option<String>,
	pub key_device:String,
	pub max_key:Option<String>,
	pub min_key:Option<String>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of record_list_get
#[derive(Debug)]
pub enum RecordListGetResponse{
	Status200(Vec<Record>),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for RecordListGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of record_list_add
#[derive(Debug)]
pub struct RecordListAddRequest{
	pub key_device:String,
	pub latitude:f64,
	pub longitude:f64,
	pub seconds:Option<u64>,
	pub body: Vec<u8>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of record_list_add
#[derive(Debug)]
pub enum RecordListAddResponse{
	Status200(Record),
	Status400(String),
	Raw(axum::response::Response),
}
impl Default for RecordListAddResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of record_get
#[derive(Debug)]
pub struct RecordGetRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of record_get
#[derive(Debug)]
pub enum RecordGetResponse{
	Status200(Record),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for RecordGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of record_update
#[derive(Debug)]
pub struct RecordUpdateRequest{
	pub key:String,
	pub body: Record,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of record_update
#[derive(Debug)]
pub enum RecordUpdateResponse{
	Status200(Record),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for RecordUpdateResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of record_delete
#[derive(Debug)]
pub struct RecordDeleteRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of record_delete
#[derive(Debug)]
pub enum RecordDeleteResponse{
	Status200,
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for RecordDeleteResponse{
	fn default() -> Self{
		Self::Status200
	}
}
// Request of test_b
#[derive(Debug)]
pub struct TestBRequest{
	pub limit:Option<i32>,
	pub cursor:Option<i32>,
	pub order:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of test_b
#[derive(Debug)]
pub enum TestBResponse{
	Status200(String),
	Raw(axum::response::Response),
}
impl Default for TestBResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of test_d
#[derive(Debug)]
pub struct TestDRequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of test_d
#[derive(Debug)]
pub enum TestDResponse{
	Status200(String),
	Raw(axum::response::Response),
}
impl Default for TestDResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of test_c
#[derive(Debug)]
pub struct TestCRequest{
	pub limit:Option<i32>,
	pub cursor:Option<i32>,
	pub order:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of test_c
#[derive(Debug)]
pub enum TestCResponse{
	Status200(String),
	Raw(axum::response::Response),
}
impl Default for TestCResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of test_a
#[derive(Debug)]
pub struct TestARequest{
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of test_a
#[derive(Debug)]
pub enum TestAResponse{
	Status200(String),
	Raw(axum::response::Response),
}
impl Default for TestAResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of user_list_get
#[derive(Debug)]
pub struct UserListGetRequest{
	pub limit:Option<i32>,
	pub order:Option<String>,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of user_list_get
#[derive(Debug)]
pub enum UserListGetResponse{
	Status200(Vec<User>),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for UserListGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of user_get
#[derive(Debug)]
pub struct UserGetRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of user_get
#[derive(Debug)]
pub enum UserGetResponse{
	Status200(User),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for UserGetResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of user_update
#[derive(Debug)]
pub struct UserUpdateRequest{
	pub key:String,
	pub body: User,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of user_update
#[derive(Debug)]
pub enum UserUpdateResponse{
	Status200(User),
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for UserUpdateResponse{
	fn default() -> Self{
		Self::Status200(Default::default())
	}
}
// Request of user_delete
#[derive(Debug)]
pub struct UserDeleteRequest{
	pub key:String,
	pub request: axum::http::Request<axum::body::Body>,
}
// Response of user_delete
#[derive(Debug)]
pub enum UserDeleteResponse{
	Status200,
	Status400(String),
	Status404(String),
	Raw(axum::response::Response),
}
impl Default for UserDeleteResponse{
	fn default() -> Self{
		Self::Status200
	}
}

#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct PathsCredentialSignInPostRequestbodyContentApplicationJsonSchema{
	pub r#has_auth:String,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct Device{
	pub r#key:String,
	pub r#key_user:String,
	pub r#name:String,
	pub r#latitude:f64,
	pub r#longitude:f64,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct Record{
	pub r#key:String,
	pub r#key_device:String,
	pub r#label:Vec<String>,
	pub r#bbox:Vec<u64>,
	pub r#latitude:f64,
	pub r#longitude:f64,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct User{
	pub r#key:String,
	pub r#name:String,
	pub r#email:String,
	pub r#auth:Vec<String>,
}
#[derive(Default,Clone,Debug,serde::Serialize,serde::Deserialize)]
pub struct Apikey{
	pub r#user:User,
	pub r#expiration:u64,
}

use axum;
#[allow(unused_imports)]
use axum::extract::FromRequest;
fn text_response(code: axum::http::StatusCode, body: String)->axum::response::Response{
	axum::response::Response::builder().header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(body)).unwrap()
}
pub fn axum_router_operations<S: ApiInterface + Sync + Send + 'static>(instance :std::sync::Arc<S>)->axum::Router{
	let router = axum::Router::new();
	let i = instance.clone();
	let router = router.route("/clean", axum::routing::delete(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::operation_clean(i.as_ref(), OperationCleanRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				OperationCleanResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				OperationCleanResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				OperationCleanResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/credential/iam", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::credential_get(i.as_ref(), CredentialGetRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				CredentialGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				CredentialGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/credential/sign_in", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::credential_sign_in(i.as_ref(), CredentialSignInRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				CredentialSignInResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				CredentialSignInResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialSignInResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialSignInResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/credential/sign_up", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::credential_sign_up(i.as_ref(), CredentialSignUpRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				CredentialSignUpResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				CredentialSignUpResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialSignUpResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialSignUpResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/credential/validate", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::credential_validate(i.as_ref(), CredentialValidateRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				CredentialValidateResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				CredentialValidateResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				CredentialValidateResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/device", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::device_list_get(i.as_ref(), DeviceListGetRequest{
				r#limit:{let v=query.get("limit").and_then(|v| v.parse().ok());v},
				r#order:{let v=query.get("order").and_then(|v| v.parse().ok());v},
				r#max_key:{let v=query.get("max_key").and_then(|v| v.parse().ok());v},
				r#min_key:{let v=query.get("min_key").and_then(|v| v.parse().ok());v},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				DeviceListGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				DeviceListGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceListGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceListGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/device", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::device_list_add(i.as_ref(), DeviceListAddRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				DeviceListAddResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				DeviceListAddResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceListAddResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/device/{key}", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::device_get(i.as_ref(), DeviceGetRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				DeviceGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				DeviceGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/device/{key}", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::device_update(i.as_ref(), DeviceUpdateRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				DeviceUpdateResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				DeviceUpdateResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceUpdateResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceUpdateResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/device/{key}", axum::routing::delete(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::device_delete(i.as_ref(), DeviceDeleteRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				DeviceDeleteResponse::Status200=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("The request has succeeded.")).unwrap(),
				DeviceDeleteResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceDeleteResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				DeviceDeleteResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/key/{key}", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::operation_key(i.as_ref(), OperationKeyRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				r#seconds:{let v=query.get("seconds").and_then(|v| v.parse().ok());v},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				OperationKeyResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				OperationKeyResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				OperationKeyResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/ml/image", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::ml_image(i.as_ref(), MlImageRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await{Ok(v)=>v.into(),Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST,format!("{v:?}"))},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				MlImageResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "image/png").body(axum::body::Body::from(v)).unwrap(),
				MlImageResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/ml/json", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::ml_json(i.as_ref(), MlJsonRequest{
				body:match axum::body::to_bytes(body, usize::MAX).await{Ok(v)=>v.into(),Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST,format!("{v:?}"))},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				MlJsonResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				MlJsonResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/record", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::record_list_get(i.as_ref(), RecordListGetRequest{
				r#limit:{let v=query.get("limit").and_then(|v| v.parse().ok());v},
				r#order:{let v=query.get("order").and_then(|v| v.parse().ok());v},
				r#key_device:{let v=query.get("key_device").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key_device in query={:?}", query))}},
				r#max_key:{let v=query.get("max_key").and_then(|v| v.parse().ok());v},
				r#min_key:{let v=query.get("min_key").and_then(|v| v.parse().ok());v},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				RecordListGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				RecordListGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordListGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/record", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::record_list_add(i.as_ref(), RecordListAddRequest{
				r#key_device:{let v=query.get("key_device").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key_device in query={:?}", query))}},
				r#latitude:{let v=query.get("latitude").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: latitude in query={:?}", query))}},
				r#longitude:{let v=query.get("longitude").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: longitude in query={:?}", query))}},
				r#seconds:{let v=query.get("seconds").and_then(|v| v.parse().ok());v},
				body:match axum::body::to_bytes(body, usize::MAX).await{Ok(v)=>v.into(),Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST,format!("{v:?}"))},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				RecordListAddResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				RecordListAddResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordListAddResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/record/{key}", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::record_get(i.as_ref(), RecordGetRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				RecordGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				RecordGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/record/{key}", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::record_update(i.as_ref(), RecordUpdateRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				RecordUpdateResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				RecordUpdateResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordUpdateResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordUpdateResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/record/{key}", axum::routing::delete(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::record_delete(i.as_ref(), RecordDeleteRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				RecordDeleteResponse::Status200=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("The request has succeeded.")).unwrap(),
				RecordDeleteResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordDeleteResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				RecordDeleteResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/test", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::test_b(i.as_ref(), TestBRequest{
				r#limit:{let v=query.get("limit").and_then(|v| v.parse().ok());v},
				r#cursor:{let v=query.get("cursor").and_then(|v| v.parse().ok());v},
				r#order:{let v=query.get("order").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: order in query={:?}", query))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				TestBResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				TestBResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/test", axum::routing::put(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::test_d(i.as_ref(), TestDRequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				TestDResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				TestDResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/test", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::test_c(i.as_ref(), TestCRequest{
				r#limit:{let v=query.get("limit").and_then(|v| v.parse().ok());v},
				r#cursor:{let v=query.get("cursor").and_then(|v| v.parse().ok());v},
				r#order:{let v=query.get("order").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: order in query={:?}", query))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				TestCResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				TestCResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/test", axum::routing::delete(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::test_a(i.as_ref(), TestARequest{
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				TestAResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				TestAResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/user", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::user_list_get(i.as_ref(), UserListGetRequest{
				r#limit:{let v=query.get("limit").and_then(|v| v.parse().ok());v},
				r#order:{let v=query.get("order").and_then(|v| v.parse().ok());v},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				UserListGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				UserListGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserListGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserListGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/user/{key}", axum::routing::get(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::user_get(i.as_ref(), UserGetRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				UserGetResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				UserGetResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserGetResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserGetResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/user/{key}", axum::routing::post(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::user_update(i.as_ref(), UserUpdateRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				body:match axum::body::to_bytes(body, usize::MAX).await.map_err(|v| format!("{v:?}")).and_then(|v| serde_json::from_slice(&v).map_err(|v| v.to_string())) {Ok(v)=>v,Err(v)=>return text_response(axum::http::StatusCode::BAD_REQUEST, v)},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				UserUpdateResponse::Status200(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "application/json").body(axum::body::Body::from(serde_json::to_vec_pretty(&v).expect("error serialize response json"))).unwrap(),
				UserUpdateResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserUpdateResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserUpdateResponse::Raw(v)=>v,
			}
		}));
	let i = instance.clone();
	let router = router.route("/user/{key}", axum::routing::delete(|
			path: axum::extract::Path<HashMap<String,String>>,
			query: axum::extract::Query<HashMap<String,String>>,
			header: axum::http::HeaderMap,
			request: axum::http::Request<axum::body::Body>,
		| async move{
			let (parts, body) = request.into_parts();
			let ret=S::user_delete(i.as_ref(), UserDeleteRequest{
				r#key:{let v=path.get("key").and_then(|v| v.parse().ok());match v {Some(v)=>v, None=>return text_response(axum::http::StatusCode::from_u16(400).unwrap(), format!("parse error: key in path={:?}", path))}},
				request: axum::http::Request::from_parts(parts.clone(), Default::default())
			}).await;
			match ret{
				UserDeleteResponse::Status200=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(200).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from("The request has succeeded.")).unwrap(),
				UserDeleteResponse::Status400(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(400).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserDeleteResponse::Status404(v)=> axum::response::Response::builder().status(axum::http::StatusCode::from_u16(404).unwrap()).header(axum::http::header::CONTENT_TYPE, "text/plain").body(axum::body::Body::from(v)).unwrap(),
				UserDeleteResponse::Raw(v)=>v,
			}
		}));
	let router = router.route("/openapi.json", axum::routing::get(|| async move{
			r###"{"openapi":"3.0.0","info":{"title":"plant mimamori","version":"0.0.0"},"servers":[{"url":"/api","description":"","variables":{}}],"paths":{"/clean":{"delete":{"operationId":"operation_clean","responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/credential/iam":{"get":{"operationId":"credential_get","responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/credential/sign_in":{"post":{"operationId":"credential_sign_in","requestBody":{"content":{"application/json":{"schema":{"type":"object","properties":{"has_auth":{"type":"string"}},"required":["has_auth"]}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/credential/sign_up":{"post":{"operationId":"credential_sign_up","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/credential/validate":{"get":{"operationId":"credential_validate","requestBody":{"content":{"application/json":{"schema":{"type":"string"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Apikey"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/device":{"get":{"operationId":"device_list_get","parameters":[{"in":"query","name":"limit","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"order","schema":{"type":"string"},"style":"form"},{"in":"query","name":"max_key","schema":{"type":"string"},"style":"form"},{"in":"query","name":"min_key","schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/Device"}}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"device_list_add","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Device"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Device"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/device/{key}":{"get":{"operationId":"device_get","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Device"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"device_update","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Device"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Device"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"delete":{"operationId":"device_delete","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded."},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/key/{key}":{"get":{"operationId":"operation_key","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"},{"in":"query","name":"seconds","schema":{"type":"integer","format":"int64"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"string"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/ml/image":{"post":{"operationId":"ml_image","requestBody":{"content":{"image/*":{"schema":{"type":"string","format":"binary"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"image/png":{"schema":{"type":"string","format":"binary"}}}}}}},"/ml/json":{"post":{"operationId":"ml_json","requestBody":{"content":{"image/*":{"schema":{"type":"string","format":"binary"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/record":{"get":{"operationId":"record_list_get","parameters":[{"in":"query","name":"limit","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"order","schema":{"type":"string"},"style":"form"},{"in":"query","name":"key_device","required":true,"schema":{"type":"string"},"style":"form"},{"in":"query","name":"max_key","schema":{"type":"string"},"style":"form"},{"in":"query","name":"min_key","schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/Record"}}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"record_list_add","parameters":[{"in":"query","name":"key_device","required":true,"schema":{"type":"string"},"style":"form"},{"in":"query","name":"latitude","required":true,"schema":{"type":"number"},"style":"form"},{"in":"query","name":"longitude","required":true,"schema":{"type":"number"},"style":"form"},{"in":"query","name":"seconds","schema":{"type":"integer","format":"uint64"},"style":"form"}],"requestBody":{"content":{"image/*":{"schema":{"type":"string","format":"binary"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Record"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/record/{key}":{"get":{"operationId":"record_get","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Record"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"record_update","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/Record"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Record"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"delete":{"operationId":"record_delete","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded."},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/test":{"get":{"operationId":"test_b","parameters":[{"in":"query","name":"limit","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"cursor","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"order","required":true,"schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"put":{"operationId":"test_d","responses":{"200":{"description":"The request has succeeded.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"test_c","parameters":[{"in":"query","name":"limit","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"cursor","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"order","required":true,"schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"delete":{"operationId":"test_a","responses":{"200":{"description":"The request has succeeded.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/user":{"get":{"operationId":"user_list_get","parameters":[{"in":"query","name":"limit","schema":{"type":"integer","format":"int32"},"style":"form"},{"in":"query","name":"order","schema":{"type":"string"},"style":"form"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/User"}}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/user/{key}":{"get":{"operationId":"user_get","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"post":{"operationId":"user_update","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}},"required":true},"responses":{"200":{"description":"The request has succeeded.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}},"delete":{"operationId":"user_delete","parameters":[{"in":"path","name":"key","required":true,"schema":{"type":"string"},"style":"simple"}],"responses":{"200":{"description":"The request has succeeded."},"400":{"description":"The server could not understand the request due to invalid syntax.","content":{"text/plain":{"schema":{"type":"string"}}}},"404":{"description":"The server cannot find the requested resource.","content":{"text/plain":{"schema":{"type":"string"}}}}}}}},"components":{"schemas":{"Apikey":{"type":"object","properties":{"user":{"$ref":"#/components/schemas/User"},"expiration":{"type":"integer","format":"uint64"}},"required":["user","expiration"]},"Device":{"type":"object","properties":{"key":{"type":"string"},"key_user":{"type":"string"},"name":{"type":"string"},"latitude":{"type":"number"},"longitude":{"type":"number"}},"required":["key","key_user","name","latitude","longitude"]},"Position":{"type":"object","properties":{"latitude":{"type":"number"},"longitude":{"type":"number"}},"required":["latitude","longitude"]},"Record":{"type":"object","properties":{"key":{"type":"string"},"key_device":{"type":"string"},"label":{"type":"array","items":{"type":"string"}},"bbox":{"type":"array","items":{"type":"integer","format":"uint64"}},"latitude":{"type":"number"},"longitude":{"type":"number"}},"required":["key","key_device","label","bbox","latitude","longitude"]},"User":{"type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"email":{"type":"string"},"auth":{"type":"array","items":{"type":"string"}}},"required":["key","name","email","auth"]}}}}"###
		}))
		.route("/ui", axum::routing::get(|| async move{
			axum::response::Html(r###"
			<html lang="en">
			<head>
			  <meta charset="utf-8" />
			  <meta name="viewport" content="width=device-width, initial-scale=1" />
			  <meta name="description" content="SwaggerUI" />
			  <title>SwaggerUI</title>
			  <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />
			</head>
			<body>
			<div id="swagger-ui"></div>
			<script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>
			<script>
			  window.onload = () => {
				window.ui = SwaggerUIBundle({
				  url: location.href.replace("/ui","/openapi.json"),
				  dom_id: '#swagger-ui',
				});
			  };
			</script>
			</body>
			</html>
			"###)
		}));
	return router;
}

pub fn axum_router<S: ApiInterface + Sync + Send + 'static>(instance: S)->axum::Router{
	let instance_arc=std::sync::Arc::new(instance);
	axum::Router::new()
		.nest_service("/api", axum_router_operations(instance_arc.clone()))
}

pub fn print_axum_router(port:u16){
	println!("http://localhost:{}/api/ui", port);
}

pub struct TestServer{}
impl ApiInterface for TestServer{}
#[allow(dead_code)]
#[tokio::main]
async fn main() {
	let port:u16 = std::env::var("PORT").unwrap_or("8080".to_string()).parse().expect("PORT should be integer");
	print_axum_router(port);
	let api = TestServer{};
	let app = axum_router(api).layer(axum::extract::DefaultBodyLimit::disable());
	let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{port}")).await.unwrap();
	axum::serve(listener, app)
		.with_graceful_shutdown(async { tokio::signal::ctrl_c().await.unwrap() })
		.await
		.unwrap();
}